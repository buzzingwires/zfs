#!/bin/ksh

#
# This file and its contents are supplied under the terms of the
# Common Development and Distribution License ("CDDL"), version 1.0.
# You may only use this file in accordance with the terms of version
# 1.0 of the CDDL.
#
# A full copy of the text of the CDDL should have accompanied this
# source.  A copy of the CDDL is also available via the Internet at
# http://www.illumos.org/license/CDDL.
#

#
# Copyright (c) 2021 by vStack. All rights reserved.
#

. "$STF_SUITE"/include/libtest.shlib
. "$STF_SUITE"/include/blkdev.shlib

#
# Description:
#
# Test whether zhack label repair can recover detached devices
# and corrupted checksums with a variety of sizes.
#
# Strategy:
#
# Tests are done on loopback devices with sizes divisible by label size and sizes that are not.
#
# Test one:
#
# 1. Create pool on a loopback device with some test data
# 2. Export the pool.
# 3. Corrupt all label checksums in the pool
# 4. Check that pool cannot be imported
# 5. Use zhack to repair label checksums in the pool
# 6. Check that pool can be imported and that data is intact
#
# Test two:
#
# 1. Create pool on a loopback device with some test data
# 2. Detach either device from the mirror
# 3. Export the pool
# 4. Delete the non-detached device
# 5. Verify that the remaining detached device cannot be imported
# 6. Use zhack to repair checksums and uberblocks in the pool
# 7. Verify that the detached device can be imported and that data is intact
#
# Test three is the same as test two, but also corrupts the detached device
# from step two.
#

log_assert "Verify zhack label repair <vdev> will repair label checksums and uberblocks"
log_onexit cleanup

VIRTUAL_DISK=$TEST_BASE_DIR/disk
VIRTUAL_MIRROR_DISK=$TEST_BASE_DIR/mirrordisk

VIRTUAL_DEVICE=
VIRTUAL_MIRROR_DEVICE=

export MINVDEVSIZE_ODD="$((MINVDEVSIZE + 1))"

function cleanup_lo
{
	L_DEVICE="$1"

	if [[ -e $L_DEVICE ]]; then
		if is_linux; then
			log_must losetup -d "$L_DEVICE"
		elif is_freebsd; then
			log_must mdconfig -d -u "$L_DEVICE"
		else
			log_must lofiadm -d "$L_DEVICE"
		fi
	fi
}

function cleanup
{
	poolexists "$TESTPOOL" && destroy_pool "$TESTPOOL"
	cleanup_lo "$VIRTUAL_DEVICE"
	cleanup_lo "$VIRTUAL_MIRROR_DEVICE"
	VIRTUAL_DEVICE=
	VIRTUAL_MIRROR_DEVICE=
	[[ -f "$VIRTUAL_DISK" ]] && log_must rm "$VIRTUAL_DISK"
	[[ -f "$VIRTUAL_MIRROR_DISK" ]] && log_must rm "$VIRTUAL_MIRROR_DISK"
}

function get_size_evenness
{
	L_SIZE="$1"

	if [ "$((L_SIZE % 2**18))" -eq 0 ]
	then
		echo "even"
	else
		echo "uneven"
	fi
}

function check_dataset
{
	log_must mounted "$TESTPOOL"/"$TESTFS"

	log_must test -f "$TESTDIR"/"test"
}

function setup_dataset
{
	log_must zfs create "$TESTPOOL"/"$TESTFS"

	log_must mkdir -p "$TESTDIR"
	log_must zfs set mountpoint="$TESTDIR" "$TESTPOOL"/"$TESTFS"

	log_must mounted "$TESTPOOL"/"$TESTFS"

	log_must touch "$TESTDIR"/"test"
	log_must test -f "$TESTDIR"/"test"

	log_must zpool sync "$TESTPOOL"

	check_dataset
}

function corrupt_labels
{
	L_DISK="$1"

	corrupt_label_checksum 0 "$L_DISK"
	corrupt_label_checksum 1 "$L_DISK"
	corrupt_label_checksum 2 "$L_DISK"
	corrupt_label_checksum 3 "$L_DISK"
}

function try_import_and_repair
{
	L_POOLDISK="$1"

	log_mustnot zpool import "$TESTPOOL" -d "$L_POOLDISK"

	log_must zhack label repair "$L_POOLDISK"

	log_must zpool import "$TESTPOOL" -d "$L_POOLDISK"
}

function prepare_vdev
{
	L_SIZE="$1"
	L_BACKFILE="$2"

	l_devname=
	if truncate -s "$L_SIZE" "$L_BACKFILE"; then
		if is_linux; then
			l_devname="$(losetup -f "$L_BACKFILE" --show)"
		elif is_freebsd; then
			l_devname=/dev/"$(mdconfig -a -t vnode -f "$L_BACKFILE")"
		else
			l_devname="$(lofiadm -a "$L_BACKFILE")"
		fi
	fi
	echo "$l_devname"
}

function run_test_one
{
	L_SIZE="$1"

	VIRTUAL_DEVICE="$(prepare_vdev "$L_SIZE" "$VIRTUAL_DISK")"
	log_must test -e "$VIRTUAL_DEVICE"

	log_must zpool create "$TESTPOOL" "$VIRTUAL_DEVICE"

	setup_dataset

	log_must zpool export "$TESTPOOL"

	corrupt_labels "$VIRTUAL_DISK"

	try_import_and_repair "$VIRTUAL_DEVICE"

	check_dataset

	cleanup

	log_pass "zhack label repair corruption test passed with $(get_size_evenness "$L_SIZE") size."
}

function make_mirrored_pool
{
	L_SIZE="$1"

	VIRTUAL_DEVICE="$(prepare_vdev "$L_SIZE" "$VIRTUAL_DISK")"
	log_must test -e "$VIRTUAL_DEVICE"
	VIRTUAL_MIRROR_DEVICE="$(prepare_vdev "$L_SIZE" "$VIRTUAL_MIRROR_DISK")"
	log_must test -e "$VIRTUAL_MIRROR_DEVICE"

	log_must zpool create "$TESTPOOL" "$VIRTUAL_DEVICE"
	log_must zpool attach "$TESTPOOL" "$VIRTUAL_DEVICE" "$VIRTUAL_MIRROR_DEVICE"
}

function export_and_cleanup_vdisk
{
	log_must zpool export "$TESTPOOL"

	cleanup_lo "$VIRTUAL_DEVICE"

	VIRTUAL_DEVICE=

	log_must rm "$VIRTUAL_DISK"
}

function run_test_two
{
	L_SIZE="$1"

	make_mirrored_pool "$L_SIZE"

	setup_dataset

	log_must zpool detach "$TESTPOOL" "$VIRTUAL_MIRROR_DEVICE"

	export_and_cleanup_vdisk

	try_import_and_repair "$VIRTUAL_MIRROR_DEVICE"

	check_dataset

	cleanup

	log_pass "zhack label repair detached recovery test passed with $(get_size_evenness "$L_SIZE") size."
}

function run_test_three
{
	L_SIZE="$1"

	make_mirrored_pool "$L_SIZE"

	setup_dataset

	log_must zpool detach "$TESTPOOL" "$VIRTUAL_MIRROR_DEVICE"

	corrupt_labels "$VIRTUAL_MIRROR_DISK"

	export_and_cleanup_vdisk

	try_import_and_repair "$VIRTUAL_MIRROR_DEVICE"

	check_dataset

	cleanup

	log_pass "zhack label repair corrupted and detached recovery test passed with $(get_size_evenness "$L_SIZE") size."
}
